---
title: 扩展方法
date: 2020-08-11 19:45:43
permalink: /pages/6e5c8d/
categories: 
  - JavaScript
  - ES6
tags: 
  - 
---

// 扩展
///////////////////////////////////////////////////////////////////////////////////////////////////////

//   字符串
    // Unicode表示法
        // 只限于\u0000——\uFFFF之间的字符
            "\u0061" // "a"
            "\uD842\uDFB7" // "𠮷"  
            "\u20BB7" // " 7"
        // 将码点放入大括号，就能正确解读该字符
            "\u{20BB7}" // "𠮷"  
            "\u{41}\u{42}\u{43}" // "ABC"  
            let hello = 123;
            hell\u{6F}; // 123 
            '\u{1F680}' === '\uD83D\uDE80' // true
        // JavaScript共有6种方法可以表示一个字符
            '\z' === 'z'  // true 
            '\172' === 'z' // true 
            '\x7A' === 'z' // true 
            '\u007A' === 'z' // true 
            '\u{7A}' === 'z' // true


/*---------------------------------------------------------- */
    // codePointAt() 返回32位的UTF-16字符的码点
        // 对于那些需要4个字节储存的字符,JavaScript会认为它们是两个字符
            var s = "𠮷";  
            s.length // 2 
            s.charAt(0) // '' 
            s.charAt(1) // '' 
            s.charCodeAt(0) // 55362 
            s.charCodeAt(1) // 57271

        // 𠮷的十进制码点134071（即十六进制的20BB7）
            var s = '𠮷a';  
            s.codePointAt(0) // 134071 
            s.codePointAt(1) // 57271  
            s.charCodeAt(2) // 97
            s.codePointAt(0).toString(16) // "20bb7" 
            s.charCodeAt(2).toString(16) // "61"

        // 解决charCodeAt()参数为2的问题
            var s = '𠮷a'; 
            for (let ch of s) {   
                console.log(ch.codePointAt(0).toString(16)); 
            } 
            // 20bb7 
            // 61

        // 测试一个字符由两个字节还是由四个字节组成
            function is32Bit(c) {   
                return c.codePointAt(0) > 0xFFFF; 
            }  
            is32Bit("𠮷") // true 
            is32Bit("a") // false
        

/*---------------------------------------------------------- */
    // String.fromCodePoint() 识别大于0xFFFF的码点
        // 解决String.fromCharCode不能识别大于0xFFFF的码点
            String.fromCharCode(0x20BB7) // "ஷ"
            String.fromCodePoint(0x20BB7) // "𠮷" 
            String.fromCodePoint(0x78, 0x1f680, 0x79) === 'x\uD83D\uDE80y' // true


/*---------------------------------------------------------- */
    // 遍历器接口for...of
      for (let codePoint of 'foo') {   
          console.log(codePoint) 
      } 
      // "f" 
      // "o" 
      // "o"

      var text = String.fromCodePoint(0x20BB7);  
      for (let i = 0; i < text.length; i++) {   
          console.log(text[i]); 
      } 
      // " " 
      // " "  

      for (let i of text) {   
          console.log(i); 
      } 
      // "𠮷"


/*---------------------------------------------------------- */
    // at()
        // ES5
            'abc'.charAt(0) // "a" 
            '𠮷'.charAt(0) // "\uD842"
        // ES6
            'abc'.at(0) // "a" 
            '𠮷'.at(0) // "𠮷"


/*---------------------------------------------------------- */
    // normalize()
        // Ǒ:（\u01D1）
            // O（\u004F）和ˇ（\u030C）合成（\u004F\u030C），JavaScript不能识别
            '\u01D1'==='\u004F\u030C' //false  
            '\u01D1'.length // 1 
            '\u004F\u030C'.length // 2
        // 将字符的不同表示方法统一为同样的形式, 不能识别三个或三个以上字符的合成
            '\u01D1'.normalize() === '\u004F\u030C'.normalize() // true


/*---------------------------------------------------------- */
    // includes(), startsWith(), endsWith()
        // JavaScript只有indexOf方法来确定字符包含关系
            var s = 'Hello world!';  
            s.startsWith('Hello') // true 
            s.endsWith('!') // true 
            s.includes('o') // true
        // 第二个参数，表示开始搜索的位置
            var s = 'Hello world!';  
            s.startsWith('world', 6) // true 
            s.endsWith('Hello', 5) // true 
            s.includes('Hello', 6) // false


/*---------------------------------------------------------- */
    // repeat()
        // 返回一个新字符串，表示将原字符串重复n次
            'x'.repeat(3) // "xxx" 
            'hello'.repeat(2) // "hellohello" 
            'na'.repeat(0) // ""
        // 小数，会被取整
            'na'.repeat(2.9) // "nana"
        // 0到-1之间的小数，则等同于0
            'na'.repeat(Infinity) // RangeError 
            'na'.repeat(-1) // RangeError
            'na'.repeat(-0.9) // ""
        // 参数NaN等同于0
            'na'.repeat(NaN) // ""
        // 字符串，则会先转换成数字
            'na'.repeat('na') // "" 
            'na'.repeat('3') // "nanana"


/*---------------------------------------------------------- */
    // padStart()，padEnd()
        // 字符串补全长度的功能
            'x'.padStart(5, 'ab') // 'ababx' 
            'x'.padStart(4, 'ab') // 'abax'  
            'x'.padEnd(5, 'ab') // 'xabab' 
            'x'.padEnd(4, 'ab') // 'xaba'
            'xxx'.padStart(2, 'ab') // 'xxx' 
            'xxx'.padEnd(2, 'ab') // 'xxx'
        // 截去超出位数的补全字符串
            'abc'.padStart(10, '0123456789') // '0123456abc'
        // 默认用空格补全
            'x'.padStart(4) // '   x' 
            'x'.padEnd(4) // 'x   '
            '1'.padStart(10, '0') // "0000000001" 
            '12'.padStart(10, '0') // "0000000012" 
            '123456'.padStart(10, '0') // "0000123456"
            '12'.padStart(10, 'YYYY-MM-DD') // "YYYY-MM-12" 
            '09-12'.padStart(10, 'YYYY-MM-DD') // "YYYY-09-12"


/*---------------------------------------------------------- */
    // 模板字符串
        // 传统写法
            $('#result').append(   
                'There are <b>' + basket.count + '</b> ' +   
                'items in your basket, ' +   
                '<em>' + basket.onSale +   
                '</em> are on sale!' 
            );
        // 用反引号（`）标识
            $('#result').append(`   
                There are <b>${basket.count}</b> items in your basket, <em>${basket.onSale}</em>  are on sale! 
            `);
        // 普通字符串 
            `In JavaScript '\n' is a line-feed.`  
        // 多行字符串 
            `In JavaScript this is  
            not legal.`  
            console.log(`string text line 1 
            string text line 2`);  
        // 字符串中嵌入变量
            var name = "Bob", time = "today"; 
            `Hello ${name}, how are you ${time}?`
        // 空格和换行，都是被保留的，使用trim方法消除换行
            $('#list').html(` 
                <ul>   
                    <li>first</li>   
                    <li>second</li> 
                </ul> 
            `.trim());
        // ${}中可以进行运算、引用对象属性、调用函数
            var x = 1; 
            var y = 2;  
            `${x} + ${y} = ${x + y}` // "1 + 2 = 3"  
            `${x} + ${y * 2} = ${x + y * 2}` // "1 + 4 = 5"  
            var obj = {x: 1, y: 2}; 
            `${obj.x + obj.y}` // 3  
            function fn() {   
                return "Hello World"; 
            }  
            `foo ${fn()} bar` // foo Hello World bar
        //   嵌套
            const tmpl = addrs => `   
                <table>   
                    ${addrs.map(addr => `     
                        <tr><td>${addr.first}</td></tr>     
                        <tr><td>${addr.last}</td></tr>   
                    `).join('')}   
                </table> 
            `;
            const data = [     
                { first: '<Jane>', last: 'Bond' },     
                { first: 'Lars', last: '<Croft>' }, 
            ];  
            console.log(tmpl(data)); 
            // <table> 
            // 
            //   <tr><td><Jane></td></tr> 
            //   <tr><td>Bond</td></tr> 
            // 
            //   <tr><td>Lars</td></tr> 
            //   <tr><td><Croft></td></tr> 
            // 
            // </table>
        // 引用模板字符串本身
            let str = 'return ' + '`Hello ${name}!`'; 
            let func = new Function('name', str); 
            func('Jack') // "Hello Jack!"   

            let str = '(name) => `Hello ${name}!`'; 
            let func = eval.call(null, str); 
            func('Jack') // "Hello Jack!"
        // 通过jsx函数，将一个DOM字符串转为React对象
            jsx`   
                <div>     
                    <input       
                        ref='input'       
                        onChange='${this.handleChange}'       
                        defaultValue='${this.state.value}' 
                    />       
                    ${this.state.value}    
                </div> 
            `


/*---------------------------------------------------------- */
    // String.raw()
        // 用来充当模板字符串的处理函数,返回一个斜杠都被转义的字符串
            String.raw`Hi\n${2+3}!`; // "Hi\\n5!"  
            String.raw`Hi\u000A!`; // 'Hi\\u000A!'
        // 斜杠已经转义不会做任何处理
            String.raw`Hi\\n` // "Hi\\n"
        // raw属性的值应该是一个数组
            String.raw({ raw: 'test' }, 0, 1, 2); // 't0e1s2t'  
            // 等同于 
            String.raw({ raw: ['t','e','s','t'] }, 0, 1, 2);

///////////////////////////////////////////////////////////////////////////////////////////////////////

//   正则
    // RegExp构造函数
      new RegExp(/abc/ig, 'i').flags // "i"
        // ES5不允许此时使用第二个参数
        // ES6可以，且会忽略原有的修饰符

/*---------------------------------------------------------- */
    // 字符串的正则方法
      String.prototype.match;   //调用 RegExp.prototype[Symbol.match]
      String.prototype.replace; //调用 RegExp.prototype[Symbol.replace]
      String.prototype.search;  //调用 RegExp.prototype[Symbol.search]
      String.prototype.split;   //调用 RegExp.prototype[Symbol.split]

/*---------------------------------------------------------- */
    // u修饰符
      // Unicode模式
        /^\uD83D/u.test('\uD83D\uDC2A'); // false 
        /^\uD83D/.test('\uD83D\uDC2A'); // true
          // \uD83D\uDC2A是一个四个字节的UTF-16编码，代表一个字符
          // 加了u修饰符以后，ES6就会识别其为一个字符
      // 点字符
        var s = '𠮷';  
        /^.$/.test(s); // false 
        /^.$/u.test(s); // true
      // Unicode字符表示法
        /\u{61}/.test('a'); // false 
        /\u{61}/u.test('a'); // true 
        /\u{20BB7}/u.test('𠮷'); // true
      // 量词
        /a{2}/.test('aa'); // true 
        /a{2}/u.test('aa'); // true 
        /𠮷{2}/.test('𠮷𠮷'); // false 
        /𠮷{2}/u.test('𠮷𠮷'); // true
        /^\u{3}$/.test('uuu'); // true
        // 没有u修饰符，所以大括号被解读为量词혀ꑍߐĀ⠰蕶 
        // 加上u修饰符，就会被解读为Unicode表达式
      // 预定义模式
        /^\S$/.test('𠮷'); // false 
        /^\S$/u.test('𠮷'); // true
        // \S是预定义模式，匹配所有不是空格的字符
        function codePointLength(text) {   
          var result = text.match(/[\s\S]/gu);   
          return result ? result.length : 0; 
        }  
        var s = '𠮷𠮷';  
        s.length // 4 
        codePointLength(s) // 2 正确返回字符串长度的函数

/*---------------------------------------------------------- */
      // i修饰符
        /[a-z]/i.test('\u212A') // false 
        /[a-z]/iu.test('\u212A') // true
        //   \u004B与\u212A都是大写的K
        //   不加u修饰符，就无法识别非规范的K字符

/*---------------------------------------------------------- */
    // y修饰符
      // 粘连修饰符，必须从下一位置开始
      // g只要求剩余位置中存在即可
      // y修饰符号隐含了头部匹配的标志^
        var s = 'aaa_aa_a'; 
        var r1 = /a+/g; 
        var r2 = /a+/y;  
        r1.exec(s) // ["aaa"] 
        r2.exec(s) // ["aaa"]  
        r1.exec(s) // ["aa"] 
        r2.exec(s) // null
      
      //g
        const REGEX = /a/g;  // 指定从2号位置（y）开始匹配 
        REGEX.lastIndex = 2;  // 匹配成功 
        const match = REGEX.exec('xaya');  // 在3号位置匹配成功 
        match.index // 3  // 下一次匹配从4号位开始 
        REGEX.lastIndex // 4  // 4号位开始匹配失败 
        REGEX.exec('xaxa') // null
      
      //y
        const REGEX = /a/y;  // 指定从2号位置开始匹配 
        REGEX.lastIndex = 2;  // 不是粘连，匹配失败 
        REGEX.exec('xaya') // null  指定从3号位置开始匹配 
        REGEX.lastIndex = 3;  // 3号位置是粘连，匹配成功 
        const match = REGEX.exec('xaxa'); 
        match.index // 3 
        REGEX.lastIndex // 4

      // 没有找到匹配 
        'x##'.split(/#/y) // [ 'x##' ]  
      // 找到两个匹配 
        '##x'.split(/#/y) // [ '', '', 'x' ]
        '#x#'.split(/#/y) // [ '', 'x#' ]  
        '##'.split(/#/y) // [ '', '', '' ]

      const REGEX = /a/gy; 
      'aaxa'.replace(REGEX, '-') // '--xa'
      'a1a2a3'.match(/a\d/y) // ["a1"] 
      'a1a2a3'.match(/a\d/gy) // ["a1", "a2", "a3"]

/*---------------------------------------------------------- */
    // sticky属性,表示是否设置了y修饰符
      var r = /hello\d/y; 
      r.sticky // true

/*---------------------------------------------------------- */
    // flags属性,返回正则表达式的修饰符
      /abc/ig.flags // 'gi'


/*---------------------------------------------------------- */
    // RegExp.escape()
      function escapeRegExp(str) {   
        return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&'); 
      }  
      let str = '/path/to/resource.html?search=query'; 
      escapeRegExp(str); 
      // "\/path\/to\/resource\.html\?search=query"

/*---------------------------------------------------------- */
    // 后行断言
      /\d+(?=%)/.exec('100% of US presidents have been male');  // ["100"] 先行断言，只匹配百分号之前的数字
      /\d+(?!%)/.exec('that’s all 44 of them') ;                // ["44"] 先行否定断言，只匹配不在百分号之前的数字
      /(?<=\$)\d+/.exec('Benjamin Franklin is on the $100 bill');  // ["100"] 后行断言,只匹配美元符号之后的数字
      /(?<!\$)\d+/.exec('it’s is worth about €90') ;               // ["90"] 后行断言,只匹配不在美元符号后面的数字
      /(?<=(\d+)(\d+))$/.exec('1053'); // ["", "1", "053"] 
      /^(\d+)(\d+)$/.exec('1053'); // ["1053", "105", "3"]
      /(?<=(o)d\1)r/.exec('hodor');  // null 
      /(?<=\1d(o))r/.exec('hodor');  // ["r", "o"]

///////////////////////////////////////////////////////////////////////////////////////////////////////

//   数值
    // 二进制和八进制表示法
      0b111110111 === 503 // true 
      0o767 === 503 // true
      // 将0b和0o前缀的字符串数值转为十进制
        Number('0b111')  // 7 
        Number('0o10')  // 8

/*---------------------------------------------------------- */
    // Number.isFinite(), 用来检查一个数值是否为有限的
      Number.isFinite(15); // true 
      Number.isFinite(0.8); // true 
      Number.isFinite(NaN); // false 
      Number.isFinite(Infinity); // false 
      Number.isFinite(-Infinity); // false 
      Number.isFinite('foo'); // false 
      Number.isFinite('15'); // false 
      Number.isFinite(true); // false
      
/*---------------------------------------------------------- */
    // Number.isNaN() , 用来检查一个值是否为NaN
      Number.isNaN(NaN) // true 
      Number.isNaN(15) // false 
      Number.isNaN('15') // false 
      Number.isNaN(true) // false 
      Number.isNaN(9/NaN) // true 
      Number.isNaN('true'/0) // true 
      Number.isNaN('true'/'true') // true

/*---------------------------------------------------------- */
    // Number.parseInt(), Number.parseFloat()
      // 全局方法parseInt()和parseFloat()，移植到Number对象上面
        Number.parseInt('12.34') // 12 
        Number.parseFloat('123.45#') // 123.45
      // 逐步减少全局性方法，使得语言逐步模块化
        Number.parseInt === parseInt // true 
        Number.parseFloat === parseFloat // true

/*---------------------------------------------------------- */
    // Number.isInteger() , 判断一个值是否为整数
      Number.isInteger(25) // true 
      Number.isInteger(25.0) // true 
      Number.isInteger(25.1) // false 
      Number.isInteger("15") // false 
      Number.isInteger(true) // false

/*---------------------------------------------------------- */
    // Number.EPSILON
      // 一个极小的常量,实质是一个可以接受的误差范围
        Number.EPSILON // 2.220446049250313e-16 
        Number.EPSILON.toFixed(20) // '0.00000000000000022204'
      // 浮点数计算是不精确的
      // 误差能够小于Number.EPSILON，我们就可以认为得到了正确结果
        0.1 + 0.2 - 0.3 // 5.551115123125783e-17  
        5.551115123125783e-17.toFixed(20) // '0.00000000000000005551' 
        5.551115123125783e-17 < Number.EPSILON // true
      function withinErrorMargin (left, right) {   
        return Math.abs(left - right) < Number.EPSILON; 
      } 
      withinErrorMargin(0.1 + 0.2, 0.3) // true 
      withinErrorMargin(0.2 + 0.2, 0.3) // false

/*---------------------------------------------------------- */
    // Number.isSafeInteger(),安全整数范围
      // JS能够准确表示的整数范围在-2^53到2^53之间（不含两个端点）
      // Number.isSafeInteger()用来判断一个整数是否落在这个范围之内
      // Number.MAX_SAFE_INTEGER和Number.MIN_SAFE_INTEGER表示这个范围的上下限
        Number.MAX_SAFE_INTEGER === Math.pow(2, 53) - 1 // true 
        Number.MAX_SAFE_INTEGER === 9007199254740991 // true  
        Number.MIN_SAFE_INTEGER === -Number.MAX_SAFE_INTEGER // true 
        Number.MIN_SAFE_INTEGER === -9007199254740991 // true

      Number.isSafeInteger('a') // false 
      Number.isSafeInteger(null) // false 
      Number.isSafeInteger(NaN) // false 
      Number.isSafeInteger(Infinity) // false 
      Number.isSafeInteger(-Infinity) // false  
      Number.isSafeInteger(3) // true 
      Number.isSafeInteger(1.2) // false 
      Number.isSafeInteger(9007199254740990) // true 
      Number.isSafeInteger(9007199254740992) // false  
      Number.isSafeInteger(Number.MIN_SAFE_INTEGER - 1) // false 
      Number.isSafeInteger(Number.MIN_SAFE_INTEGER) // true 
      Number.isSafeInteger(Number.MAX_SAFE_INTEGER) // true 
      Number.isSafeInteger(Number.MAX_SAFE_INTEGER + 1) // false

/*---------------------------------------------------------- */
    // Math对象的扩展
      // Math.trunc() 去除一个数的小数部分，返回整数部分
        Math.trunc(4.1) // 4 
        Math.trunc(4.9) // 4 
        Math.trunc(-4.1) // -4 
        Math.trunc(-4.9) // -4 
        Math.trunc(-0.1234) // -0
        Math.trunc('123.456') // 123 将其先转为数值
        Math.trunc(NaN);      // NaN 
        Math.trunc('foo');    // NaN 
        Math.trunc();         // NaN

      // Math.sign() 判断一个数到底是正数、负数、还是零
        Math.sign(-5) // -1 
        Math.sign(5) // +1 
        Math.sign(0) // +0 
        Math.sign(-0) // -0 
        Math.sign(NaN) // NaN 
        Math.sign('foo'); // NaN 
        Math.sign();      // NaN

      // Math.cbrt() 用于计算一个数的立方根
        Math.cbrt(-1) // -1 
        Math.cbrt(0)  // 0 
        Math.cbrt(1)  // 1 
        Math.cbrt(2)  // 1.2599210498948734
        Math.cbrt('8') // 2 
        Math.cbrt('hello') // NaN

      // Math.clz32()  JavaScript的整数使用32位二进制形式表示,返回一个数的32位无符号整数形式有多少个前导0
        Math.clz32(0) // 32 
        Math.clz32(1) // 31 
        Math.clz32(1000) // 22 
        Math.clz32(0b01000000000000000000000000000000) // 1 
        Math.clz32(0b00100000000000000000000000000000) // 2
        Math.clz32(0) // 32 
        //   1的二进制形式是0b1，只占1位，所以32位之中有31个前导0
          Math.clz32(1) // 31 
        //   左移运算符（<<）与Math.clz32方法直接相关
          Math.clz32(1 << 1) // 30 
          Math.clz32(1 << 2) // 29 
          Math.clz32(1 << 29) // 2
        //   对于小数，Math.clz32方法只考虑整数部分
          Math.clz32(3.2) // 30 
          Math.clz32(3.9) // 30
        Math.clz32() // 32 
        Math.clz32(NaN) // 32 
        Math.clz32(Infinity) // 32 
        Math.clz32(null) // 32 
        Math.clz32('foo') // 32 
        Math.clz32([]) // 32 
        Math.clz32({}) // 32 
        Math.clz32(true) // 31
      
      // Math.imul()  返回两个数以32位带符号整数形式相乘的结果，返回的也是一个32位的带符号整数
        Math.imul(2, 4)   // 8 
        Math.imul(-1, 8)  // -8 
        Math.imul(-2, -2) // 4
        //   对于那些很大的数的乘法，低位数值往往都是不精确的, 它们的乘积超过了2的53次方
          (0x7fffffff * 0x7fffffff)|0 // 0
        //   Math.imul方法可以返回正确的值1
          Math.imul(0x7fffffff, 0x7fffffff) // 1
      
      // Math.fround() 返回一个数的单精度浮点数形式
        Math.fround(0)     // 0 
        Math.fround(1)     // 1 
        Math.fround(1.337) // 1.3370000123977661 
        Math.fround(1.5)   // 1.5 
        Math.fround(NaN)   // NaN
      
      // Math.hypot()返回所有参数的平方和的平方根
        Math.hypot(3, 4);        // 5     3的平方加上4的平方，等于5的平方
        Math.hypot(3, 4, 5);     // 7.0710678118654755 
        Math.hypot();            // 0 
        Math.hypot(NaN);         // NaN 
        Math.hypot(3, 4, 'foo'); // NaN 
        Math.hypot(3, 4, '5');   // 7.0710678118654755 
        Math.hypot(-3);          // 3
      
      // Math.expm1() 返回ex-1，即Math.exp(x) - 1
        Math.expm1(-1) // -0.6321205588285577 
        Math.expm1(0)  // 0 
        Math.expm1(1)  // 1.718281828459045
      
      // Math.log1p() 返回1 + x的自然对数，即Math.log(1 + x)。如果x小于-1，返回NaN
        Math.log1p(1)  // 0.6931471805599453 
        Math.log1p(0)  // 0 
        Math.log1p(-1) // -Infinity 
        Math.log1p(-2) // NaN
      
      // Math.log10() 返回以10为底的x的对数。如果x小于0，则返回NaN
        Math.log10(2)      // 0.3010299956639812 
        Math.log10(1)      // 0 
        Math.log10(0)      // -Infinity 
        Math.log10(-2)     // NaN 
        Math.log10(100000) // 5
      
      // Math.log2() 返回以2为底的x的对数。如果x小于0，则返回NaN
        Math.log2(3)       // 1.584962500721156 
        Math.log2(2)       // 1 
        Math.log2(1)       // 0 
        Math.log2(0)       // -Infinity 
        Math.log2(-2)      // NaN 
        Math.log2(1024)    // 10 
        Math.log2(1 << 29) // 29
      
      Math.sinh(x) // 返回x的双曲正弦
      Math.cosh(x) // 返回x的双曲余弦
      Math.tanh(x) // 返回x的双曲正切
      Math.asinh(x) // 返回x的反双曲正弦
      Math.acosh(x) // 返回x的反双曲余弦
      Math.atanh(x) // 返回x的反双曲正切

/*---------------------------------------------------------- */
    // 指数运算符
      2 ** 2 // 4 
      2 ** 3 // 8

      let a = 2; 
      a **= 2; 
      // 等同于 
      a = a * a; 

      let b = 3; 
      b **= 3; 
      // 等同于 
      b = b * b * b;

///////////////////////////////////////////////////////////////////////////////////////////////////////

// 数组
    // Array.from() 
      //用于将两类对象转为真正的数组
        let arrayLike = {     
          '0': 'a',     
          '1': 'b',     
          '2': 'c',     
          length: 3 
        };  
        let arr2 = Array.from(arrayLike); // ['a', 'b', 'c'] ES6的写法 
      
      //querySelectorAll方法返回的是一个类似数组的对象(必须有length属性)
        // NodeList对象 
          let ps = document.querySelectorAll('p'); 
          Array.from(ps).forEach(function (p) {   
            console.log(p); 
          });  
        // arguments对象 
          function foo() {   
            var args = Array.from(arguments);   
            // ... 
          }

      //扩展运算符（...）也可以将某些数据结构转为数组
        // arguments对象 
          function foo() {   
            var args = [...arguments]; 
          }  
        // NodeList对象 
          [...document.querySelectorAll('div')] 

      //部署了Iterator接口的数据结构，Array.from都能将其转为数组
        Array.from('hello') // ['h', 'e', 'l', 'l', 'o']  
        let namesSet = new Set(['a', 'b']) 
        Array.from(namesSet) // ['a', 'b']

      // from()第二个参数，作用类似于数组的map方法
        Array.from(arrayLike, x => x * x); 
        // 等同于 
        Array.from(arrayLike).map(x => x * x);  
        Array.from([1, 2, 3], (x) => x * x) // [1, 4, 9] 

      //取出一组DOM节点的文本内容
        let spans = document.querySelectorAll('span.name');  
        // map() 
        let names1 = Array.prototype.map.call(spans, s => s.textContent);  
        // Array.from() 
        let names2 = Array.from(spans, s => s.textContent) 

      //将数组中布尔值为false的成员转为0
        Array.from([1, , 2, , 3], (n) => n || 0) // [1, 0, 2, 0, 3] 

      //返回各种数据的类型
        function typesOf () {   
          return Array.from(arguments, value => typeof value) 
        } 
        typesOf(null, [], NaN) // ['object', 'object', 'number']
        
      //// 
      Array.from({ length: 2 }, () => 'jack') // ['jack', 'jack']
      function countSymbols(string) {   
        return Array.from(string).length; 
      }


/*---------------------------------------------------------- */
    // Array.of() 将一组值，转换为数组
      Array.of(3, 11, 8) // [3,11,8] 
      Array.of(3) // [3] 
      Array.of(3).length // 1
        
/*---------------------------------------------------------- */
    // fill() 使用给定值，填充一个数组
      //数组中已有的元素，会被全部抹去
        ['a', 'b', 'c'].fill(7) // [7, 7, 7]  
        new Array(3).fill(7) // [7, 7, 7]
      
      // 第二个和第三个参数，用于指定填充的起始位置和结束位置
        ['a', 'b', 'c'].fill(7, 1, 2) // ['a', 7, 'c']

/*---------------------------------------------------------- */
    // includes() 返回一个布尔值，表示某个数组是否包含给定的值,代替indexOf()
      [1, 2, 3].includes(2);     // true 
      [1, 2, 3].includes(4);     // false 
      [1, 2, NaN].includes(NaN); // true
        
      // 第二个参数表示搜索的起始位置，默认为0
        [1, 2, 3].includes(3, 3);  // false 
        [1, 2, 3].includes(3, -1); // true

/*---------------------------------------------------------- */
    // copyWithin() 将指定位置的成员复制到其他位置，然后返回当前数组
      Array.prototype.copyWithin(target, start = 0, end = this.length)
        
      // 从3号位直到数组结束的成员（4和5）， 复制到从0号位开始的位置，结果覆盖了原来的1和2
        [1, 2, 3, 4, 5].copyWithin(0, 3) // [4, 5, 3, 4, 5]
      // 将3号位复制到0号位 
        [1, 2, 3, 4, 5].copyWithin(0, 3, 4) // [4, 2, 3, 4, 5]  
      // -2相当于3号位，-1相当于4号位 
        [1, 2, 3, 4, 5].copyWithin(0, -2, -1) // [4, 2, 3, 4, 5]  
      // 将3号位复制到0号位 
        [].copyWithin.call({length: 5, 3: 1}, 0, 3) // {0: 1, 3: 1, length: 5}  
      // 将2号位到数组结束，复制到0号位 
        var i32a = new Int32Array([1, 2, 3, 4, 5]); 
        i32a.copyWithin(0, 2); // Int32Array [3, 4, 5, 4, 5]  
      // 对于没有部署TypedArray的copyWithin方法的平台 ,需要采用下面的写法 
        [].copyWithin.call(new Int32Array([1, 2, 3, 4, 5]), 0, 3, 4); // Int32Array [4, 2, 3, 4, 5]

/*---------------------------------------------------------- */
    // find() 用于找出第一个符合条件的数组成员
      [1, 4, -5, 10].find((n) => n < 0) // -5
      // find方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组
      [1, 5, 10, 15].find(function(value, index, arr) {   
        return value > 9; 
      }) // 10

/*---------------------------------------------------------- */
    // findIndex() 返回第一个符合条件的数组成员的位置,所有成员都不符合条件，则返回-1
      [1, 5, 10, 15].findIndex(function(value, index, arr) {   
        return value > 9; 
      }) // 2
      // 都可以发现NaN，弥补了数组的IndexOf方法的不足
        [NaN].indexOf(NaN) // -1  
        [NaN].findIndex(y => Object.is(NaN, y)) // 0

/*---------------------------------------------------------- */
    // entries()，keys()和values() 用于遍历数组，返回一个遍历器对象
      for (let index of ['a', 'b'].keys()) {   
        console.log(index); 
      } 
      // 0 
      // 1

      for (let elem of ['a', 'b'].values()) {   
        console.log(elem); 
      } 
      // 'a' 
      // 'b'  
      
      for (let [index, elem] of ['a', 'b'].entries()) {   
        console.log(index, elem); 
      } 
      // 0 "a" 
      // 1 "b"

      // 手动调用遍历器对象的next方法，进行遍历
        let letter = ['a', 'b', 'c']; 
        let entries = letter.entries(); 
        console.log(entries.next().value); // [0, 'a'] 
        console.log(entries.next().value); // [1, 'b'] 
        console.log(entries.next().value); // [2, 'c']

        
/*---------------------------------------------------------- */
    // 空位
      // 返回一个具有3个空位的数组，空位不是undefined，一个位置的值等于undefined
        Array(3) // [, , ,]
      // 将数组的空位，转为undefined
        Array.from(['a',,'b']); // [ "a", undefined, "b" ] 
        [...['a',,'b']]; // [ "a", undefined, "b" ]
        [,'a','b',,].copyWithin(2,0); // [,"a",,"a"]
        new Array(3).fill('a'); // ["a","a","a"]
        let arr = [, ,]; 
        for (let i of arr) {   
          console.log(1); 
        } 
        // 1 
        // 1

      // entries() 
        [...[,'a'].entries()]; // [[0,undefined], [1,"a"]]  
      // keys() 
        [...[,'a'].keys()]; // [0,1]  
      // values() 
        [...[,'a'].values()]; // [undefined,"a"]  
      // find() 
        [,'a'].find(x => true); // undefined  
      // findIndex() 
        [,'a'].findIndex(x => true); // 0


///////////////////////////////////////////////////////////////////////////////////////////////////////

// 函数
    // 参数默认值
      // ES6允许为函数的参数设置默认值, 之前必须这样定义y = y || 'World';
        function log(x, y = 'World') {   
          console.log(x, y); 
        }  
        log('Hello') // Hello World 
        log('Hello', 'China') // Hello China 
        log('Hello', '') // Hello

      // 参数变量x是默认声明的, 在函数体中，不能用let或const再次声明
        function Point(x = 0, y = 0) {   
          this.x = x;   
          this.y = y; 
        }  
        var p = new Point(); 
        p // { x: 0, y: 0 }

      // 与解构赋值默认值结合使用
        function foo({x, y = 5}) {   
          console.log(x, y); 
        }  
        foo({}) // undefined, 5 
        foo({x: 1}) // 1, 5 
        foo({x: 1, y: 2}) // 1, 2 
        foo() // TypeError: Cannot read property 'x' of undefined

      // 不能省略第二个参数
        function fetch(url, { body = '', method = 'GET', headers = {} }) {   
          console.log(method); 
        }  
        fetch('http://example.com', {}) // "GET"  
        fetch('http://example.com') // 报错

      // 双重默认值
        function fetch(url, { method = 'GET' } = {}) {   
          console.log(method); 
        }  
        fetch('http://example.com') // "GET"

      // 不同的默认值定义方式
        // 写法一 
          function m1({x = 0, y = 0} = {}) {   
            return [x, y]; 
          }  
        // 写法二 
          function m2({x, y} = { x: 0, y: 0 }) {   
            return [x, y]; 
          }
        // 函数没有参数的情况 
          m1() // [0, 0] 
          m2() // [0, 0]  
        // x和y都有值的情况 
          m1({x: 3, y: 8}) // [3, 8] 
          m2({x: 3, y: 8}) // [3, 8]  
        // x有值，y无值的情况 
          m1({x: 3}) // [3, 0] 
          m2({x: 3}) // [3, undefined]  
        // x和y都无值的情况 
          m1({}) // [0, 0]; 
          m2({}) // [undefined, undefined]  
          m1({z: 3}) // [0, 0] 
          m2({z: 3}) // [undefined, undefined]

      // 定义了默认值的参数，应该是函数的尾参数, 无法只省略该参数，而不省略它后面的参数
        // 例一 
          function f(x = 1, y) {   
            return [x, y]; 
          }  
          f() // [1, undefined] 
          f(2) // [2, undefined]) 
          f(, 1) // 报错 
          f(undefined, 1) // [1, 1]  
        // 例二 
          function f(x, y = 5, z) {   
            return [x, y, z]; 
          }  
          f() // [undefined, 5, undefined] 
          f(1) // [1, 5, undefined] 
          f(1, ,2) // 报错 
          f(1, undefined, 2) // [1, 5, 2]

      // length属性，将返回没有指定默认值的参数个数
        (function (a) {}).length // 1 
        (function (a = 5) {}).length // 0 
        (function (a, b, c = 5) {}).length // 2

      // 如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了
        (function (a = 0, b, c) {}).length // 0 
        (function (a, b = 1, c) {}).length // 1


/*---------------------------------------------------------- */
    // rest参数
      // ES6引入rest参数（形式为“...变量名”），用于获取函数的多余参数
      // rest参数之后不能再有其他参数
      // 函数的length属性，不包括rest参数
        function add(...values) {   
          let sum = 0;    
          for (var val of values) {     
            sum += val;   
          }    
          return sum; 
        }  
        add(2, 5, 3) // 10
      // 代替arguments变量
        // arguments变量的写法 
          function sortNumbers() {   
            return Array.prototype.slice.call(arguments).sort(); 
          }  
        // rest参数的写法 
          const sortNumbers = (...numbers) => numbers.sort();

/*---------------------------------------------------------- */
    // 扩展运算符（...）
      // 将一个数组转为用逗号分隔的参数序列
        console.log(...[1, 2, 3]); // 1 2 3  
        console.log(1, ...[2, 3, 4], 5); // 1 2 3 4 5  
        [...document.querySelectorAll('div')] // [<div>, <div>, <div>]

        function push(array, ...items) {   
          array.push(...items); 
        }  
        function add(x, y) {   
          return x + y; 
        }  
        var numbers = [4, 38]; 
        add(...numbers) // 42

      // 替代数组的apply方法
        // ES5的写法 
          function f(x, y, z) {   
            // ... 
          } 
          var args = [0, 1, 2]; 
          f.apply(null, args);  
        // ES6的写法 
          function f(x, y, z) {   
            // ... 
          } 
          var args = [0, 1, 2]; 
          f(...args);

        // ES5的写法 
          Math.max.apply(null, [14, 3, 77])  
        // ES6的写法 
          Math.max(...[14, 3, 77])  
          Math.max(14, 3, 77);

        // ES5的写法 
          var arr1 = [0, 1, 2]; 
          var arr2 = [3, 4, 5]; 
          Array.prototype.push.apply(arr1, arr2);  
        // ES6的写法 
          var arr1 = [0, 1, 2]; 
          var arr2 = [3, 4, 5]; 
          arr1.push(...arr2);

        // ES5 
          new (Date.bind.apply(Date, [null, 2015, 1, 1])) 
        // ES6 
          new Date(...[2015, 1, 1]);

      // 合并数组
        // ES5 
          [1, 2].concat(more); 
        // ES6 
          [1, 2, ...more];  
          var arr1 = ['a', 'b']; 
          var arr2 = ['c']; 
          var arr3 = ['d', 'e'];  
        // ES5的合并数组 
          arr1.concat(arr2, arr3); // [ 'a', 'b', 'c', 'd', 'e' ]  
        // ES6的合并数组 
          [...arr1, ...arr2, ...arr3] // [ 'a', 'b', 'c', 'd', 'e' ]

      // 与解构赋值结合, 用于数组赋值时只能放在参数的最后一位
        // ES5 
          a = list[0], rest = list.slice(1) 
        // ES6 
          [a, ...rest] = list
        const [first, ...rest] = [1, 2, 3, 4, 5]; 
        first // 1 
        rest  // [2, 3, 4, 5]  
        const [first, ...rest] = []; 
        first // undefined 
        rest  // []:  
        const [first, ...rest] = ["foo"]; 
        first  // "foo" 
        rest   // []

      // 函数的返回值
        var dateFields = readDateFields(database); 
        var d = new Date(...dateFields);

      // 将字符串转为真正的数组
        [...'hello'] // [ "h", "e", "l", "l", "o" ]
        'x\uD83D\uDE80y'.length; // 4 
        [...'x\uD83D\uDE80y'].length; // 3
        let str = 'x\uD83D\uDE80y';  
        str.split('').reverse().join('') // 'y\uDE80\uD83Dx'  
        [...str].reverse().join('') // 'y\uD83D\uDE80x'

      // Iterator接口的对象，都可以用扩展运算符转为真正的数组
        var nodeList = document.querySelectorAll('div'); 
        var array = [...nodeList];

        let arrayLike = {   
          '0': 'a',   
          '1': 'b',   
          '2': 'c',   
          length: 3 
        };  
        // TypeError: Cannot spread non-iterable object. 
        let arr = [...arrayLike];

      // 变量go是一个Generator函数
        var go = function*(){   
          yield 1;   
          yield 2;   
          yield 3; 
        };  
        [...go()] // [1, 2, 3]

        let map = new Map([   
          [1, 'one'],   
          [2, 'two'],   
          [3, 'three'], 
        ]);  
        let arr = [...map.keys()]; // [1, 2, 3]
    
/*---------------------------------------------------------- */
    // 严格模式
      // 函数参数使用了默认值、解构赋值、或者扩展运算符， 那么函数内部就不能显式设定为严格模式'use strict';
    
/*---------------------------------------------------------- */
    // name属性
      // 返回该函数的函数名
        function foo() {} 
        foo.name // "foo"
      // 匿名函数
        var func1 = function () {};  
        // ES5 
        func1.name // ""  
        // ES6 
        func1.name // "func1"
      // 具名函数
        const bar = function baz() {};  
        // ES5 
        bar.name // "baz"  
        // ES6 
        bar.name // "baz"
      // 构造函数实例
        (new Function).name // "anonymous"
      // bind返回的函数, 加上“bound ”前缀
        function foo() {}; 
        foo.bind({}).name // "bound foo"  
        (function(){}).bind({}).name // "bound "
    
/*---------------------------------------------------------- */
    // 箭头函数 =>
      // 箭头左边为参数，右边为返回值或代码块
        var f = v => v;  
        //等同于 
        var f = function(v) {   
          return v; 
        };

      // 不需要参数或需要多个参数用()表示
        var f = () => 5; 
        // 等同于 
        var f = function () { return 5 };  

        var sum = (num1, num2) => num1 + num2; 
        // 等同于 
        var sum = (num1, num2) => { return num1 + num2; }
        var sum = function(num1, num2) {   return num1 + num2; };

      // 直接返回一个对象，必须在对象外面加上括号
        var getTempItem = id => ({ id: id, name: "Temp" });

      // 与变量解构结合使用
        const full = ({ first, last }) => first + ' ' + last;  
        // 等同于 
        function full(person) {   
          return person.first + ' ' + person.last; 
        }

      // rest参数与箭头函数结合
        const numbers = (...nums) => nums;  
        numbers(1, 2, 3, 4, 5) // [1,2,3,4,5]  
        const headAndTail = (head, ...tail) => [head, tail];  
        headAndTail(1, 2, 3, 4, 5) // [1,[2,3,4,5]]

        const isEven = n => n % 2 == 0; 
        const square = n => n * n;

      // 简化回调函数
        // 正常函数写法 
          [1,2,3].map(function (x) {   
            return x * x; 
          });  
        // 箭头函数写法 
          [1,2,3].map(x => x * x);
        // 正常函数写法 
          var result = values.sort(function (a, b) {   
            return a - b; 
          });  
        // 箭头函数写法 
          var result = values.sort((a, b) => a - b);

/*---------------------------------------------------------- */ 
    // 绑定 this
      // 函数绑定运算符是并排的两个双冒号（::），双冒号左边是一个对象，右边是一个函数，取代call、apply、bind调用
        foo::bar; 
        // 等同于 
        bar.bind(foo);  

        foo::bar(...arguments); 
        // 等同于 
        bar.apply(foo, arguments);  

        const hasOwnProperty = Object.prototype.hasOwnProperty; 
        function hasOwn(obj, key) {   
          return obj::hasOwnProperty(key); 
        }

      // 左边为空，右边是一个对象的方法，则等于将该方法绑定在该对象上面
        var method = obj::obj.foo; 
        // 等同于 
        var method = ::obj.foo;  

        let log = ::console.log; 
        // 等同于 
        var log = console.log.bind(console);

      // 采用链式写法
        // 例一 
          import { map, takeWhile, forEach } from "iterlib";  
          getPlayers() 
          ::map(x => x.character()) 
          ::takeWhile(x => x.strength > 100) 
          ::forEach(x => console.log(x));  
        // 例二 
          let { find, html } = jake;  
          document.querySelectorAll("div.myClass") 
          ::find("p") 
          ::html("hahaha");


/*---------------------------------------------------------- */
    // 尾调用优化
      // 最后一步是调用另一个函数，只保留内层函数的调用帧才叫优化
        function f(x){   
          return g(x); 
        }
      // 函数调用自身，称为递归。如果尾调用自身，就称为尾递归
        function factorial(n) {   
          if (n === 1) return 1;   
          return n * factorial(n - 1); 
        }  
        factorial(5) // 120


/*---------------------------------------------------------- */
    // 参数尾逗号
      // 允许函数的最后一个参数有尾逗号
        function clownsEverywhere( 
          param1,   
          param2, 
        ) { /* ... */ }  
        clownsEverywhere(   
          'foo',   
          'bar', 
          );

///////////////////////////////////////////////////////////////////////////////////////////////////////

  // 对象
    // 属性的简洁表示法
      // 属性名为变量名, 属性值为变量的值
        var foo = 'bar'; 
        var baz = {foo}; 
        baz // {foo: "bar"}  
        // 等同于 
        var baz = {foo: foo};

        function f(x, y) {   
          return {x, y}; 
        }  
        // 等同于  
        function f(x, y) {   
          return {x: x, y: y}; 
        } 
        f(1, 2) // Object {x: 1, y: 2}

      // 方法也可以简写
        var o = {   
          method() {     
            return "Hello!";   
          } 
        };  
        // 等同于  
        var o = {   
          method: function() {     
            return "Hello!";   
          } 
        };

        var birth = '2000/01/01';  
        var Person = {    
          name: '张三',   
          birth,    //等同于 birth: birth 
          hello() { console.log('我的名字是', this.name); }  // 等同于hello: function ()...   
        };

      // 用于函数的返回值
        function getPoint() {   
          var x = 1;   
          var y = 10;   
          return {x, y}; 
        }  
        getPoint() // {x:1, y:10}

      // CommonJS模块输出变量
        var ms = {};  
        function getItem (key) {   
          return key in ms ? ms[key] : null; 
        }  
        function setItem (key, value) {   
          ms[key] = value; 
        }  
        function clear () {   
          ms = {}; 
        }  
        module.exports = { getItem, setItem, clear }; 
        // 等同于 
        module.exports = {   
          getItem: getItem,   
          setItem: setItem,   
          clear: clear 
        };
        
      // 属性的赋值器（setter）和取值器（getter）
        var cart = {   
          _wheels: 4,    
          get wheels () {     
            return this._wheels;   
          },    
          set wheels (value) {     
            if (value < this._wheels) {       
              throw new Error('数值太小了！');     
            }     
            this._wheels = value;   
          } 
        }

      // 属性名总是字符串
        var obj = {   
          class () {} 
        };  
        // 等同于  
        var obj = {   
          'class': function() {} 
        };
        
      // 某个方法的值是一个Generator函数，前面需要加上星号
        var obj = {   
          * m(){     
            yield 'hello world';   
          } 
        };
/*---------------------------------------------------------- */
    // 属性名表达式 []
      // 定义对象的属性
        // 方法一 
          obj.foo = true;  
        // 方法二 
          obj['a' + 'bc'] = 123;
          
      // 把表达式放在方括号内
        var lastWord = 'last word';  
        var a = {   
          'first word': 'hello',   
          [lastWord]: 'world' 
        };  
        a['first word'] // "hello" 
        a[lastWord]  // "world" 
        a['last word']  // "world"

      // 表达式还可以用于定义方法名
        let obj = {   
          ['h'+'ello']() {     
            return 'hi';   
          } 
        };  
        obj.hello() // hi

      // 属性名表达式与简洁表示法，不能同时使用
        // 报错 
          var foo = 'bar'; 
          var bar = 'abc'; 
          var baz = { [foo] };  
        // 正确 
          var foo = 'bar'; 
          var baz = { [foo]: 'abc'};

/*---------------------------------------------------------- */
    // 方法的name属性
      // 对象方法也是函数，因此也有name属性
        var person = {   
          sayName() {     
            console.log(this.name);   
          },   
          get firstName() {     
            return "Nicholas";   
          } 
        };  
        person.sayName.name   // "sayName" 
        person.firstName.name // "get firstName"

      // bind方法创造的函数，name属性返回加上前缀“bound”
      // Function构造函数创造的函数，name属性返回“anonymous”
        (new Function()).name // "anonymous"
        var doSomething = function() {   
          // ... 
        }; 
        doSomething.bind().name // "bound doSomething"
        const key1 = Symbol('description'); 
        const key2 = Symbol(); 
        let obj = {
          [key1]() {},   
          [key2]() {}, 
        }; 
        obj[key1].name // "[description]" 
        obj[key2].name // ""

/*---------------------------------------------------------- */
    // Object.is()
      // 用于解决相等运算符（==）和严格相等运算符（===）缺点
        Object.is('foo', 'foo') // true 
        Object.is({}, {}) // false
        +0 === -0 //true 
        NaN === NaN // false  
        Object.is(+0, -0) // false 
        Object.is(NaN, NaN) // true

/*---------------------------------------------------------- */
    // Object.assign()
      // 用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）
        var target = { a: 1 };  
        var source1 = { b: 2 }; 
        var source2 = { c: 3 };  
        Object.assign(target, source1, source2); 
        target // {a:1, b:2, c:3}

      // 如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性
        var target = { a: 1, b: 1 };  
        var source1 = { b: 2, c: 2 }; 
        var source2 = { c: 3 };  
        Object.assign(target, source1, source2); 
        target // {a:1, b:2, c:3}

      // 参数不是对象，则会先转成对象
        typeof Object.assign(2) // "object"

      // undefined和null无法转成对象
        Object.assign(undefined) // 报错 
        Object.assign(null) // 报错

      // 只有一个参数，Object.assign会直接返回该参数
      // 如果undefined和null不在首参数，就不会报错
        let obj = {a: 1}; 
        Object.assign(obj) === obj // true 
        Object.assign(obj, undefined) === obj // true 
        Object.assign(obj, null) === obj // true

      // 数值、字符串和布尔值 不在首参数，不会产生效果，也不会报错
      // 字符串会以数组形式，拷贝入目标对象
        var v1 = 'abc'; 
        var v2 = true; 
        var v3 = 10;  
        var obj = Object.assign({}, v1, v2, v3); 
        console.log(obj); // { "0": "a", "1": "b", "2": "c" }

      // 布尔值、数值、字符串分别转成对应的包装对象
      // 内部属性[[PrimitiveValue]]不会被Object.assign拷贝
        Object(true) // {[[PrimitiveValue]]: true} 
        Object(10)  //  {[[PrimitiveValue]]: 10} 
        Object('abc') // {0: "a", 1: "b", 2: "c", length: 3, [[PrimitiveValue]]: "abc"}

      //合并数组
        Object.assign([1, 2, 3], [4, 5]) // [4, 5, 3]

      // 常见用途
        // 为对象添加属性
          class Point {   
            constructor(x, y) {     
              Object.assign(this, {x, y});   
            } 
          }

        // 为对象添加方法
          Object.assign(SomeClass.prototype, {   
            someMethod(arg1, arg2) {     
              ···   
            },   
            anotherMethod() {    
              ···   
            } 
          });  
          // 等同于下面的写法 
          SomeClass.prototype.someMethod = function (arg1, arg2) {   
            ··· 
          }; 
          SomeClass.prototype.anotherMethod = function () {   
            ··· 
          };

        // 克隆对象
          // 只能克隆原始对象自身的值，不能克隆它继承的值
            function clone(origin) {   
              return Object.assign({}, origin); 
            }
          // 保持继承链
            function clone(origin) {   
              let originProto = Object.getPrototypeOf(origin);   
              return Object.assign(Object.create(originProto), origin); 
            }

        // 合并多个对象，合并后返回一个新对象
          const merge =   (target, ...sources) => Object.assign(target, ...sources);
          const merge =   (...sources) => Object.assign({}, ...sources);
            
        // 为属性指定默认值
          // 如果两者有同名属性，则option的属性值会覆盖DEFAULTS的属性值
          const DEFAULTS = {   
            logLevel: 0,   
            outputFormat: 'html' 
          };  
          function processContent(options) {   
            options = Object.assign({}, DEFAULTS, options); 
          }

/*---------------------------------------------------------- */
    // 属性的可枚举性
      // 获取该属性的描述对象
      // Object.assign()，会忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性
        let obj = { foo: 123 }; 
        Object.getOwnPropertyDescriptor(obj, 'foo')
        //  { 
        //    value: 123, 
        //    writable: true, 
        //    enumerable: true,  // enumerable属性，称为”可枚举性“
        //    configurable: true 
        //  }
        
      // toString和length属性的enumerable都是false， 因此for...in不会遍历到这两个继承自原型的属性
      // 所有Class的原型的方法都是不可枚举的
        Object.getOwnPropertyDescriptor(Object.prototype, 'toString').enumerable // false  
        Object.getOwnPropertyDescriptor([], 'length').enumerable // false

/*---------------------------------------------------------- */
    // 属性的遍历
      // 遍历对象自身的和继承的可枚举属性（不含Symbol属性）
        for...in
      // 返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含Symbol属性）
        Object.keys(obj)
      // 返回一个数组，包含对象自身的所有属性,不含Symbol属性
        Object.getOwnPropertyNames(obj)
      // 返回一个数组，包含对象自身的所有Symbol属性
        Object.getOwnPropertySymbols(obj)
      // 返回一个数组，包含对象自身的所有属性
        Reflect.ownKeys(obj)
      // 遍历的次序规则
        // 首先遍历所有属性名为数值的属性，按照数字排序。
        // 其次遍历所有属性名为字符串的属性，按照生成时间排序。
        // 最后遍历所有属性名为Symbol值的属性，按照生成时间排序。
        Reflect.ownKeys({ [Symbol()]:0, b:0, 10:0, 2:0, a:0 }) // ['2', '10', 'b', 'a', Symbol()]

/*---------------------------------------------------------- */
    // __proto__
      // __proto__属性用来读取或设置当前对象的prototype对象
      // 无论从语义的角度，还是从兼容性的角度，都不要使用这个属性，而是使用下面的
        // es6的写法 
          var obj = {   
            method: function() { ... } 
          }; 
          obj.__proto__ = someOtherObj;  
        // es5的写法 
          var obj = Object.create(someOtherObj); 
          obj.method = function() { ... };

      // Object.setPrototypeOf() 设置原型对象
        // 格式 
          Object.setPrototypeOf(object, prototype)  
        // 用法 
          var o = Object.setPrototypeOf({}, null);
        // 将proto对象设为obj对象的原型，所以从obj对象可以读取proto对象的属性
          let proto = {}; 
          let obj = { x: 10 }; 
          Object.setPrototypeOf(obj, proto);  
          proto.y = 20; 
          proto.z = 40;  
          obj.x // 10 
          obj.y // 20 
          obj.z // 40

      // Object.getPrototypeOf() 读取一个对象的prototype对象
        function Rectangle() { }  
        var rec = new Rectangle();  
        Object.getPrototypeOf(rec) === Rectangle.prototype // true  
        Object.setPrototypeOf(rec, Object.prototype); 
        Object.getPrototypeOf(rec) === Rectangle.prototype // false

/*---------------------------------------------------------- */
    // Object.values()
      // ES5引入了Object.keys方法，返回一个数组，成员是参数对象自身的所有可遍历属性的键名
        var obj = { foo: "bar", baz: 42 }; 
        Object.keys(obj) // ["foo", "baz"]
      // Object.values方法返回一个数组，成员是参数对象自身的所有可遍历属性的键值
        let {keys, values, entries} = Object; 
        let obj = { a: 1, b: 2, c: 3 };  
        for (let key of keys(obj)) {   
          console.log(key); // 'a', 'b', 'c' 
        }  
        for (let value of values(obj)) {   
          console.log(value); // 1, 2, 3 
        }  
        for (let [key, value] of entries(obj)) {   
          console.log([key, value]); // ['a', 1], ['b', 2], ['c', 3] 
        }
      // 过滤属性名为Symbol值的属性
        var obj = { foo: "bar", baz: 42 }; 
        Object.values(obj) // ["bar", 42]
        Object.values({ [Symbol()]: 123, foo: 'abc' }); // ['abc']
        Object.values('foo') // ['f', 'o', 'o']
        Object.values(42) // [] 
        Object.values(true) // []

/*---------------------------------------------------------- */
    // Object.entries()
      // 返回一个数组，成员是参数对象自身的所有可遍历属性的键值对数组, Symbol值会被省略
        var obj = { foo: 'bar', baz: 42 }; 
        Object.entries(obj) // [ ["foo", "bar"], ["baz", 42] ]
      // 遍历对象的属性
        let obj = { one: 1, two: 2 }; 
        for (let [k, v] of Object.entries(obj)) {   
          console.log(`${JSON.stringify(k)}: ${JSON.stringify(v)}`); 
        } 
        // "one": 1 
        // "two": 2
      // 将对象转为真正的Map结构
        var obj = { foo: 'bar', baz: 42 }; 
        var map = new Map(Object.entries(obj)); 
        map // Map { foo: "bar", baz: 42 }

/*---------------------------------------------------------- */
    // 对象的扩展运算符
      // 解构赋值
        // 解构赋值必须是最后一个参数
          let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 }; 
          x // 1 
          y // 2 
          z // { a: 3, b: 4 }
          let { x, y, ...z } = null; // 运行时错误 
          let { x, y, ...z } = undefined; // 运行时错误
          let { ...x, y, z } = obj; // 句法错误 
          let { x, ...y, ...z } = obj; // 句法错误

        // 解构赋值的拷贝是浅拷贝
        // 复合类型的值拷贝的是这个值的引用
          let obj = { a: { b: 1 } }; 
          let { ...x } = obj; 
          obj.a.b = 2; 
          x.a.b // 2

        // 解构赋值不会拷贝继承自原型对象的属性
          let o1 = { a: 1 }; 
          let o2 = { b: 2 }; 
          o2.__proto__ = o1; 
          let o3 = { ...o2 }; 
          o3 // { b: 2 }

        // 解构赋值产生的变量y和z，只能读取对象自身的属性，所以只有变量z可以赋值成功
          var o = Object.create({ x: 1, y: 2 }); 
          o.z = 3;  
          let { x, ...{ y, z } } = o; 
          x // 1 
          y // undefined 
          z // 3

        // 扩展某个函数的参数
          function baseFunction({ a, b }) {   
            // ... 
          } 
          function wrapperFunction({ x, y, ...restConfig }) {   
            // 使用x和y参数进行操作   
            // 其余参数传给原始函数   
            return baseFunction(restConfig); 
          }

      // 扩展运算符
        // 取出参数对象的所有可遍历属性，拷贝到当前对象之中
          let z = { a: 3, b: 4 }; 
          let n = { ...z }; 
          n // { a: 3, b: 4 }

          let aClone = { ...a }; 
          // 等同于 
          let aClone = Object.assign({}, a);

        // 合并两个对象
          let ab = { ...a, ...b }; 
          // 等同于 
          let ab = Object.assign({}, a, b);

        // a对象的x属性和y属性，拷贝到新对象后会被覆盖掉
          let aWithOverrides = { ...a, x: 1, y: 2 }; 
          // 等同于 
          let aWithOverrides = { ...a, ...{ x: 1, y: 2 } }; 
          // 等同于 
          let x = 1, y = 2, aWithOverrides = { ...a, x, y }; 
          // 等同于 
          let aWithOverrides = Object.assign({}, a, { x: 1, y: 2 });

        // newVersion对象自定义了name属性， 其他属性全部复制自previousVersion对象
          let newVersion = {   
            ...previousVersion,   
            name: 'New Name' // Override the name property 
          };

        // 自定义属性放在扩展运算符前面，就变成了设置新对象的默认属性值
          let aWithDefaults = { x: 1, y: 2, ...a }; 
          // 等同于 
          let aWithDefaults = Object.assign({}, { x: 1, y: 2 }, a); 
          // 等同于 
          let aWithDefaults = Object.assign({ x: 1, y: 2 }, a);

        // 这个两个值会被忽略
          let emptyObject = { ...null, ...undefined }; // 不报错

/*---------------------------------------------------------- */
    // Object.getOwnPropertyDescriptors()
      // 返回指定对象所有自身属性（非继承属性）的描述对象
        const obj = {   
          foo: 123,   
          get bar() { return 'abc' } 
        };  
        Object.getOwnPropertyDescriptors(obj) 
        // { foo: 
        //    { value: 123, 
        //      writable: true, 
        //      enumerable: true, 
        //      configurable: true 
        //    }, 
        //   bar: 
        //    { get: [Function: bar], 
        //      set: undefined, 
        //      enumerable: true, 
        //      configurable: true 
        //   } 
        // }  

      // 为了解决Object.assign()无法正确拷贝get属性和set属性的问题
      // 因为Object.assign方法总是拷贝一个属性的值，而不会拷贝它背后的赋值方法或取值方法
        const source = {   
          set foo(value) {     
            console.log(value);   
          } 
        };  
        const target1 = {}; 
        Object.assign(target1, source);  
        Object.getOwnPropertyDescriptor(target1, 'foo') 
        // { value: undefined, 
        //   writable: true, 
        //   enumerable: true, 
        //   configurable: true }

      // 可以实现正确拷贝
        const source = {   
          set foo(value) {     
            console.log(value);   
          } 
        };  
        const target2 = {}; 
        Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source)); 
        Object.getOwnPropertyDescriptor(target2, 'foo') 
        // { get: undefined, 
        //   set: [Function: foo], 
        //   enumerable: true, 
        //   configurable: true }

      // 简写
        const shallowMerge = (target, source) => Object.defineProperties(   
          target,   
          Object.getOwnPropertyDescriptors(source) 
        );

      // 将对象属性克隆到一个新对象。这属于浅拷贝。
        const clone = Object.create(
          Object.getPrototypeOf(obj),   
          Object.getOwnPropertyDescriptors(obj));  
        // 或者  
        const shallowClone = (obj) => Object.create(   
          Object.getPrototypeOf(obj),   
          Object.getOwnPropertyDescriptors(obj) 
        );

      // 一个对象继承另一个对象
        const obj = Object.create(prot); 
        obj.foo = 123;  
        // 或者  
        const obj = Object.assign(   
          Object.create(prot),   
          {foo: 123,} 
        );  
        //现在 
        const obj = Object.create(   
          prot,   
          Object.getOwnPropertyDescriptors({foo: 123,}) 
        );

      // 用来实现Mixin（混入）模式
      // 对象a和b被混入了对象c
        let mix = (object) => ({   
          with: (...mixins) => mixins.reduce(     
            (c, mixin) => Object.create(       
              c, Object.getOwnPropertyDescriptors(mixin)     
            ), object) 
          });  

        // multiple mixins example 
          let a = {a: 'a'}; 
          let b = {b: 'b'}; 
          let c = {c: 'c'}; 
          let d = mix(c).with(a, b);